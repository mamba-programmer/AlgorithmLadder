# 排序算法(Sorting Algorithm) - O(n^2)

## 1. 什么是排序算法(Sorting Algorithm)？

通俗的来讲，排序算法是指将一段数据按照某个特征进行排列的算法。

排序算法可以分为：内排序算法与外排序算法。

内排序算法是指将所有数据都记录在内存中进行排序的方法，比如本章内容要介绍的在数组中的排序。

外排序算法是指在内存不够的情况下，对存储在一个或者多个大文件中的数据进行排序的算法。

外排序算法通常是解决大数据处理问题的一个重要步骤，关于外排序的内容，会在之后的章节详细介绍。

注：本章所讲的排序算法均为时间复杂度为 $O(n^2)$ 的内排序算法

## 2. 冒泡排序(Bubble Sort)

冒泡排序是一种非常直观的排序方式，它的核心思想是通过遍历数组并不断交换两个相邻的数字来达到数组的有序化。

由于整个算法的过程像是在将一个数字慢慢"上浮"到数组的末端，因此被形象地称为冒泡排序。

在这里，向大家推荐一个网站：[旧金山大学算法与数据结构可视化工具](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html ) ，可以详细地看到各种算法与数据结构的动态演示，在系列教程中，将会有大量动态图片来源于此网站，比如现在所讲的冒泡排序：

![冒泡排序演示](https://github.com/jiuzhangsuanfa/AlgorithmLadder/blob/master/Level%202/Image/%5BL2-1%5D%20bubble%20sort%20animation.gif?raw=true)

在上面的演示图片中，每次红色的标记走完数组时，可以发现，数组中**未排序部分的数字的最大值**被移动到了**未排序部分的末端**，就像把这个数字"上浮"到它应该在的位置。

那么该如何实现这个"上浮"的操作呢？

此时需要使用一个 **for循环**，来不断对相邻的两个数字进行比较，如果位于前面的数字更大，则将两个数字交换位置：

```java
int[] array = {3, 6, 5, 1, 4, 7, 2};

// 取 len(array)-1 是为了防止下标越界
for (int j = 0; j < array.length - 1; j++) {
    // 如果前面的数更大
    if (array[j] > array[j + 1]) {
        // 交换两个数字的位置
        int temp = array[j];
        array[j] = array[j + 1];
        array[j + 1] = temp;
    }
}

// 打印数组
System.out.println(Arrays.toString(array));

/*
output :
[3, 5, 1, 4, 6, 2, 7]
*/
```

```python
array = [3, 6, 5, 1, 4, 7, 2]

# 取 len(array)-1 是为了防止下标越界
for j in range(len(array) - 1):
    # 如果前面的数更大
    if array[j] > array[j + 1]:
        # 交换两个数字的位置
        array[j], array[j + 1] = array[j + 1], array[j]
        
# 打印数组
print(array)

'''
output :
[3, 5, 1, 4, 6, 2, 7]
'''
```

可以看到，原数组 `[3, 6, 5, 1, 4, 7, 2]` 在循环了一次之后变成了 `[3, 5, 1, 4, 6, 2, 7]` ，也就是说，最大的数字 `7` "上浮" 到了数组的末端。

如果再次执行循环，数组则会由 `[3, 6, 5, 1, 4, 7, 2]` 变成 `[3, 1, 4, 5, 2, 6, 7]` ，这时第二大的数字 `6` 便 "上浮" 到了数组的倒数第二个位置。

所以这里可以总结出：如果执行了 `k` 次循环，那么前 `k` 大的数字便会 "上浮" 到数组的尾端。

**那么怎么排序所有数字呢？**

其实排序所有数字，就相当于前 `n` 大的数字都 "上浮" 到了数组的尾端，也就是说，上面代码中的循环要执行 `n` 次（此处 `n` 是数组中元素的个数），那么只需要在上面代码的外面再套一层 **for循环** 就好了，详细代码见下：

```java
int[] array = {3, 6, 5, 1, 4, 7, 2};

for (int i = 0; i < array.length; i++) {
    // 取 len(array)-1 是为了防止下标越界
    for (int j = 0; j < array.length - 1; j++) {
        // 如果前面的数更大
        if (array[j] > array[j + 1]) {
            // 交换两个数字的位置
            int temp = array[j];
            array[j] = array[j + 1];
            array[j + 1] = temp;
        }
    }
}

// 打印数组
System.out.println(Arrays.toString(array));

/*
output :
[1, 2, 3, 4, 5, 6, 7]
*/
```

```python
array = [3, 6, 5, 1, 4, 7, 2]

for i in range(len(array)):
    # 取 len(array)-1 是为了防止下标越界
    for j in range(len(array) - 1):
        # 如果前面的数更大
        if array[j] > array[j + 1]:
            # 交换两个数字的位置
            array[j], array[j + 1] = array[j + 1], array[j]
            
# 打印数组
print(array)

'''
output :
[1, 2, 3, 4, 5, 6, 7]
'''
```



